---
title: "Data Science for Socioeconomists"
subtitle: "Excercise 4 - Reproducible research"
author: Lisa Wegner & Junbo Huang
format:
  revealjs:
    code-overflow: wrap
    smaller: true
    scrollable: true
    echo: true
    incremental: true
    transition: none
    background-transition: none
    theme: white
    slide-number: true
    footer: "Data Science for Socioeconomists"
    embed-resources: true
    preview-links: auto 
    output-file: "Session_4_Reproducible Research.html"
editor: visual
code-annotations: below
---

# Agenda for today

1.  Troubleshooting Guide
2.  Input on guidelines
3.  Example: use of Llama
4.  Input on Reproducible science
5.  Tasks

# Troubleshooting

![](https://cdn.memes.com/up/23422781594433255/i/1595886688295.jpg)

-   We have created a link-list with all things helpful - this can be found under "helpful stuff" [at OpenOlat](https://www.openolat.uni-hamburg.de/auth/RepositoryEntry/340099667/CourseNode/108537309191894)

-   The code of the lecture-, exercise- and solution slides can be copied! This way you can adapt it to your needs and don't need to start from scratch.

## Usage of AI tools like UHHGPT {#sec-usage-of-ai-tools-like-uhhgpt}

::: callout-warning
Even though its tempting: Try not to simply copy-paste answers given by AI. Instead you should try to understand the code there and work with that new knowledge in your own code.
:::

***Helpful prompts:***

-   To understand code from lecture/tutorial-slides: "Please explain *this code* to me and tell me, which steps were taken."

-   To inform yourself about other solutions: "I have *this code* for *this kind of problem*. Please show me a different way of solving that problem"

-   To inform yourself about packages/functions: "I want to solve *this problem*. Is there an existing package for that purpose? Can I use an existing function? Please tell me its name and give an example for the usage."

::: callout-note
check out the information of the university in the matter of AI

<https://www.isa.uni-hamburg.de/ddlitlab/gki/gki-landing-page.html>
:::

# Guidelines {#sec-guidelines-to-names-in-coding}

## names {#sec-names-in-coding}

"Naming variables follow a simple idea: Create variables that describe their function and which follow a consistent theme throughout your code." (Coding best practices [by University of Colorado Boulder](https://curc.readthedocs.io/en/latest/programming/coding-best-practices.html))

::: nonincremental
-   Multiword expressions - choose **one** theme and stick with it!
    -   whitespace should not be used

    -   Snakecase: variable_one; variable_two (Words are delimited by an underscore)

    -   PascalCase: VariableOne; VariableTwo (Words are delimited by capital letters)

    -   camelcase: variableOne; variableTwo (Words are delimited by capital letters, except the initial word)
:::

## using comments {#sec-guidelines-for-using-comments}

*" It is entirely possible to “over comment” code. Code should be designed in an efficient, consistent and intuitive manner such that comments enhance user understanding but are not needed to describe the entire code."* (Coding best practices [by University of Colorado Boulder](https://curc.readthedocs.io/en/latest/programming/coding-best-practices.html))

```{r}
test_function <- function(birthyear) { #commenting here works fine
   age <- #commenting here creates an error 2024 - birthyear 
     age <- 2024 - birthyear
   # commenting here creates an error return (age)
   return(age) # commenting here works
}

test_function(1921)
```

## Example: Making "AI"s with [Llama 3](https://huggingface.co/meta-llama/Meta-Llama-3-8B) {#sec-example-making-ais-with-llama-3}

-   Llama-3-8b is an open-source large language model (LLM) with 8 billion parameters

-   Popular model used in AI research

-   You can use the provided Llama instance locally hosted in the Semantic Systems Group (SEMS) within the Computer Science Department in UHH.

-   y = Llama3(x, temperature, max_tokens)

    ::: callout-important
    -   **temperature** is a parameter of generation, ranging from 0 to 2. Higher temperature introduces randomness/creativity.
    -   **max_token** is a parameter deciding the maximum length of the generated sequence.
    -   Please do not share the following code snippet.
    :::

    ::: notes
    1.  to develop this blackbox view on function, that whatever is defined in the blackbox does not matter, as long as we know what to expect as inputs and outputs. So we do not need to know how packages and functions are defined. 

    2.  which also helps to showcase how to look into code documentation (e.g., to find what the function is doing, to find input/output format so we can use the function properly)
    :::

```{r}
# Load necessary libraries
library(httr)
library(glue)
library(jsonlite)

# Define the function
llama3 <- function(model_param, x, temperature=0.2, max_new_tokens=10) {
  # Define the URL
  url <- "https://turbo.skynet.coypu.org/"
  
  # Create the request payload as a list
  data <- list(
    messages = list(
      list(
        role = "user",
        content = paste0(model_param, "\n", x)
      )
    ),
    temperature = 0.2,
    max_new_tokens = 10
  )
  
  # Attempt the POST request
  tryCatch({
    # Make the POST request, encoding the body as JSON
    response <- POST(url, body = data, encode = "json")
    
    # Check if the request was successful
    if (status_code(response) == 200) {
      # Parse the response content
      content_data <- content(response, as = "parsed", type = "application/json")
      
      # Extract and return the "content" field if available
      return(content_data$content)
    } else {
      # Handle the case where the request fails
      stop("Request failed with status code: ", status_code(response))
    }
  }, error = function(e) {
    # Catch and return any errors encountered
    return(e$message)
  })
}
```

## Theory-driven Naming {#sec-theory-driven-naming}

::: notes
to showcase naming of variables reflects how you want to look at the problem 
:::

Prompts are sequences of tokens that can be split in multiple parts. For example it can express :

-   a context "instantiating" model parameters,
-   and an independent variable.

```{r}
# Example of in-context learning: machine translation
model_param <- "English: Hello, German: Hallo"
x <- "English: are you fine?"
y <- llama3(model_param, x) 
print(y)
```

## Use-case-driven Naming {#sec-use-case-driven-naming}

::: notes
to showcase code comments in a more complex function and encourage that complex functions are not intimidating 
:::

Prompts can express task-oriented information.

```{r}
# Use glue to create a formatted string
# Define sub-strings
en <- "Bye"
de <- "Auf wiedersehen"

# glue together template and sub-strings to construct a dictionary
dictionary <- glue("English: {en}, German: {de}")
print(dictionary)

# define dictionary look-up key
key <- "English: What's up?"
value <- llama3(dictionary, key)
print(value)
```

# Recap: Reproducible Science {#sec-recap-reproducible-science}

::: callout-important
-   Reproducibility isn't a guarantee of quality
    -   Value depends on other factors like originality of the question, validity of hypotheses, relevance of results to the field, and the quality of conclusions drawn
    -   Specific context or conditions could limit the generalizability
-   Diversity in research standards: Physical experiments have different standards than social science studies
-   Human factors and interpretation can influence the interpretation and conclusions of results
:::

## Measurement of Risk: Bus Factor {#subsec-bus-factor}

-   There is a project with *n* responsible persons
-   Thus, *bus_factor = n*
-   Small *n* depicts higher risk in project
-   How to reduce impact: documentation

# Exercise:

## 1. Correct poorly documented code {#sec-1.-correct-poorly-documented-code}

The provided code snippet performs a data analysis task but lacks proper documentation, comments, and variable labels. Your task is to enhance the code by adding comments, providing clear variable names, and improving readability. Rewrite the code to make it more understandable for future collaborators.

# Code

```{r}
f <- function(a) {
  if (!is.numeric(a) || a < 0) {
    return("Error!")
  }
  
  if (a < 16) {
    return("Too young")
  } else if (a < 18) {
    return("Beer and wine")
  } else {
    return("All good")
  }
}

# Function calls
print(f(15))  # Too young
print(f(17))  # Beer and wine
print(f(20))  # All good
print(f(-1))  # Error!
print(f("20"))  # Error!
```

## **Questions:**

1.  Identify at least three issues with the provided code example in terms of documentation and variable naming.
2.  Why is it important to have clear and descriptive variable names in code for reproducible research?
3.  How does adding comments to code contribute to the reproducibility of research?

## 2. Rework of last weeks code {#sec-2.-rework-of-last-weeks-code}

Take a look at your code from last week and enhance its readability and reproducibility. Things to look out for could be

1.  Look at variable names. Are they self-explanatory?
2.  Place comments in places where they are needed
